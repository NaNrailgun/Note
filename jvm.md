## JVM整理

**JDK 1.8 之前：**

![img](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

**JDK 1.8 ：**

![img](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)

线程私有：程序计数器、虚拟机栈、本地方法栈

线程共享：堆、方法区、直接内存

### 程序计数器

字节码解释器通过改变程序计数器去依次读取指令，实现代码流程的控制。

程序计数器是用来记录线程运行位置的，当发生线程切换时能够通过程序计数器保存线程的运行位置。

### 虚拟机栈

虚拟机栈存储了栈帧，每一次调用一个方法的时候就会往虚拟机栈里面压入一个栈帧，当方法结束的时候，这个栈帧就会从虚拟机栈里弹出。栈帧存储了局部变量表，局部变量表存储了基本数据类型和对象引用

- **`StackOverFlowError`：** 栈深度溢出。
- **`OutOfMemoryError`：** 栈拓展失败。

如果线程请求的栈深度超过虚拟机所允许的深度抛StackOverflowError，如果虚拟机栈的容量是允许动态拓展的时候，当栈拓展时无法申请到足够的内存抛OutOfMemoryError，如果其他线程被创建的时候虚拟机栈申请不到足够空间的时候也会抛OutOfMemoryError

### 本地方法栈

虚拟机栈执行Java方法，本地方法栈执行的是Native方法，HotSpot将本地方法栈和虚拟机栈合并了。

在栈深度溢出时抛StackOverflowError，在栈拓展失败的时候抛OutOfMemoryError

### 堆

Java中，几乎所有的对象都在堆上分配，但有些对象经过逃逸分析发现没有发生逃逸的话就会直接在栈上分配。1.8之前，堆分为新生代、老年代、永久代。1.8的时候永久代被废除，取而代之的是元空间。

新生代还分为：伊甸园、from survivor、to survivor

1. **`OutOfMemoryError: GC Overhead Limit Exceeded`** ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发`java.lang.OutOfMemoryError: Java heap space` 错误。(和本机物理内存无关，和你配置的内存大小有关！)

### 方法区

方法区是Java虚拟机规范规定的，永久代是HotSpot对方法区的一个实现，方法区和永久代的关系好比接口和实现类。

方法区用于存储已被**虚拟机加载的类信息、常量、静态变量**等数据。

当方法区无法满足新的内存分配需求的时候抛OutOfMemoryError

为什么使用元空间代替永久代？

1.永久代有一个jvm本身设置的大小上限，无法进行调整。元空间使用的是直接内存吗，受本机可用内存限制，虽然元空间还是有内存溢出的风险，但比原来出现的机率要小很多。当你元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`

2.因为元空间可以做到只受系统内存大小的限制，所以能加载的类就更多了。

运行时常量池

运行时常量池是方法区的一部分，用来存放编译期生成的各种字面量和符号引用，这部分数据会在类加载后存放到方法区的运行时常量池里。

1. **JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代**
2. **JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代** 。
3. **JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)**

### 直接内存

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

各内存区域oom：

1.堆：对象不断创建且gcroot可达

2.虚拟机栈 & 本地方法栈：线程太多导致新建线程无法申请到虚拟机栈空间或栈空间拓展失败

3.方法区（元空间）：代理类不断创建

>元空间gc的条件
>
>* 该类所有的实例都已经被回收；
>
>* 加载该类的ClassLoader已经被回收；
>
>* 该类对应的java.lang.Class对象没有任何地方被引用。

4.直接内存：使用NIO等直接使用直接内存（现象:堆快照小，且有使用直接内存）

对象的创建

1.类加载检查

当虚拟机遇到一个new指令的时候，他会去检查这个指令的参数能不能在常量池中定位到一个类的符号引用，然后检查这个类有没有被加载、解析、初始化过。如果没有的话就需要先执行类的加载过程。

2.分配内存

在类加载检查通过后，虚拟机为新生的对象分配内存。（对象所需要的内存大小在类加载完成之后就能确定了）

分配内存的两种方式：

* 内存是规整的：指针碰撞

将已经分配的内存放在一边，将还没分配的内存放在一边，中间拿一个指针分隔。

* 内存不是规整的：空闲列表

维护一个列表，分配内存时查表分配。

>  内存分配的并发问题
>
> 1.cas失败重试。
>
> 2.TLAB，虚拟机为每一个线程预先分配出一块内存，叫做TLAB，分配内存的时候现在TLAB分配，在TLAB内存用完之后使用cas分配。

3.初始化零值

在内存分配完之后需要将内存空间都初始化零值，这一步保证了Java的类实例中，成员变量不用赋初始值就能使用。

4.设置对象头

记录对象的类的元数据信息，对象的GC分代年龄...

5.执行init方法

我就直接理解成执行构造方法。

对象的内存布局

3部分：对象头、实例数据、对其填充

对象头：

对象头包括两部分：1.存储对象自身运行时的数据（hashCode，分代年龄，锁标志...）

2.类型指针，指向这个对象的类的元数据的指针，虚拟机通过这个指针来确定这个对象属于哪个类。

实例数据：

存储程序中设置的对象成员变量的值。

对其填充：

保证对象必须是8个字节的整数倍。

对象的访问定位：

1.引用存储的是句柄，使用句柄的话需要在内存划出一部分空间作为句柄池，引用存储的是对象句柄的地址，句柄包含了对象对象的地址。

2.直接使用指针访问，引用直接访问堆中的对象。

使用句柄的好处：引用中存储了稳定的句柄指针，对象移动时只需要改变句柄的实例对象指针，引用不用修改。

使用直接指针的好处：少了一步指针定位的开销。

GC

1.部分收集

Minor GC/Young GC：只对新生代进行收集

Major GC/Old GC：只对老年代进行垃圾收集，Major GC在一些语境下也表示Full GC

2.整堆收集（Full GC）

收集整个Java堆和方法区

判断对象是否死亡

1.引用计数法：每当有一个地方引用这个对象的时候，引用计数器加1，引用失效，引用计数器减1。难解决对象之间循环引用的问题。

2.可达性分析：以GC root对象为起点向下扫描，扫描过的路径叫做引用链，当一个对象没有和任何的GC root的引用链相连的话就证明这个对象不可达，可以进行回收。

三色标记

白，灰，黑

解决并发标记问题（造成对象“消失”）：

赋值器插入了一条或者多条黑色对象到白色对象的引用【1】，然后删除了全部灰色对象对该白色对象的直接或者间接引用【2】。

1.增量更新，破坏【1】条件，当黑色对象插入指向白色对象的引用关系时，将这个引用记录下来，等并发扫描结束之后，再将这些记录的黑色对象为根，再扫描一遍。

2.原始快照，破坏【2】条件，当灰色对象将要删除对白色对象的引用的时候，将这次删除记录下来，等并发标记结束之后，以记录的灰色对象为根，再扫描一遍。

可作为GC root 的对象：

1.虚拟机栈（栈帧中的本地变量表）中引用的对象

2.本地方法栈（Native方法）中引用的对象

3.方法区中类的静态属性引用的变量

4.方法区中常量引用的变量：

方法区包含常量池，字符串常量池包含字符串对象作为gc root（常量池为方法区的东西，只不过把方法区拆分到堆和元空间两部分实现而已，不要混淆）

判断常量是否被废弃

该常量没有被任何对象引用

判断类是否无用

1.堆中不存在该类及其派生子类的实例

2.加载该类的classloader已经被回收

3.该类对应的class对象没有被引用

垃圾回收算法：

1.标记清除

2.标记复制

3.标记整理

4.分代收集：

把堆分成新生代和老年代，这样的话就能根据各个年代的特点去选择合适的垃圾回收算法。

在新生代中，每次收集都会有大量对象死去，那么就使用标记复制算法。

在老年代中，对象的成活率是比较高的，所以使用标记清除或者标记整理算法会好一些。

垃圾回收器

![image-20201105232946947](jvm.assets/image-20201105232946947.png)



![image-20201105233723725](jvm.assets/image-20201105233723725.png)

![image-20201105233741613](jvm.assets/image-20201105233741613.png)



Parallel Scavenge收集器基于标记复制实现，Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。

![image-20201105234220134](jvm.assets/image-20201105234220134.png)









