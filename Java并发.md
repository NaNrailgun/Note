## Java并发

#### 进程

进程是程序的一次执行过程，是系统运行程序和资源分配的基本单位。

#### 线程

线程被称为轻量级进程，一个进程在执行过程中可以产生多个线程，他们共享进程的资源。线程是cpu调度的基本单位。

在Java中，多个线程共享进程的堆和方法区资源，而每个线程都有自己的程序计数器，虚拟机栈和本地方法栈。

#### 进程和线程的区别

* 资源：进程是资源分配的基本单位，线程不拥有资源，但线程可以访问他隶属的进程的资源。
* 调度：线程是cpu调度的基本单位，同一进程中的线程切换不会导致线程切换，但从一个进程的线程切换到另一个进程的线程就会导致进程的切换。
* 开销：进程涉及资源的分配和回收，进程的创建和销毁的开销会远大于线程。进程切换涉及进程cpu环境的保存和新调度进程cpu环境的设置，线程只需要保存和设置少量的寄存器内容，所以切换的时候进程的开销也会远大于线程。
* 通信：进程通信需要借助IPC，线程可以直接通过读写进程中的数据进行通信。

#### 线程的生命周期

操作系统中线程的状态：新建，就绪，运行，等待，结束。

Java的Thread类中有一个State枚举类，定义了Java线程的6种状态。

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| new          | 初始状态。线程被创建，但还没调用其start方法                  |
| runnable     | 运行状态。Java把操作系统线程的就绪和运行状态都称为运行状态   |
| blocked      | 阻塞状态。表示线程阻塞于锁（synchronized）                   |
| waiting      | 等待状态。当调用Object.wait、Thread.join、LockSupport.park且无限定等待时间 |
| time_waiting | 超时等待状态。Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos\|parkUntil |
| terminated   | 终止状态。线程已执行完成                                     |

#### 线程状态转化

![image-20201015164602279](Java并发.assets/image-20201015164602279.png)

#### 上下文切换

当前线程在执行完cpu时间片之后切换到另一个线程之前会先保存自己的状态，下次再切换回来的时候可以再加载这个线程的状态。

#### 线程死锁

线程A持有资源1，线程B持有资源2，他们同时都想申请对方的资源，这两个线程都在互相等待对方释放资源，而且会无限的等待下去，就出现了死锁。

##### 避免线程死锁

1.一次性申请所有资源。

2.占用部分资源的线程进一步申请其他资源时，如果申请不到就主动释放它占有的资源。

3.按顺序申请资源。释放资源反向释放资源。

#### 多线程使用

1.继承Thread，重写run方法

2.实现Runnable接口，实现run方法

3.实现Callable接口，实现call方法

```java
public class CallableTest implements Callable<String> {
    @Override
    public String call() throws Exception {
        return "ko no Dio da !";
    }
}

class CallableTestMain{
    public static void main(String[] args) {
        CallableTest callableTest = new CallableTest();
        FutureTask<String> futureTask = new FutureTask<>(callableTest);
        Thread thread = new Thread(futureTask);
        thread.start();
        try {
            System.out.println(futureTask.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

#### volatitle

* JMM

  JMM是一个抽象模型。在这个模型里面，所有的共享变量都存储在主存，每个线程还有自己的工作内存，各个线程的工作内存保留了被线程使用到的变量副本，线程对变量的操作都是在工作内存完成的，不能直接操作主内存中的变量，而且，不同线程之间不能直接访问对方工作内存的变量，需要通过主存中转来实现。

工作内存对应cpu缓存，主存对应主内存。

* cpu缓存

  cpu中需要cpu高速缓存去解决内存访问过慢的问题。cpu一般有三级缓存，然后通过一些缓存一致性协议来保证缓存之间的数据一致性。

* 缓存一致性协议 MESI

  当cpu写数据的时候，如果发现操作的变量是共享变量的话，也就是说这个变量在其他cpu的缓存中也存在一个副本，那么他会发出信号去通知其他cpu将这个变量的缓存行设置为无效状态，这时候如果其他cpu需要读取这个变量时，会发现缓存该变量的缓存行是无效的，所以就会去主存重新读取。

  每个处理器通过嗅探总线上传播的数据来检查自己的缓存值是不是过期了，当处理器发现自己缓存行的共享变量被修改了就会将当前的缓存行设置为无效，当处理器需要对这个变量进行操作的时候就得重新去主存读取。

  如果大量使用volatitle的话，会产生总线风暴。在多核处理器中，各个cpu核心通过总线和内存进行数据交互，如果大量使用volatile的话，那么每个cpu核心就需要不断地进行总线嗅探，无效的交互会导致总线的带宽达到峰值，使得cpu处理效率下降。（cas也会导致总线风暴）

* volatile特性

  1.volatile保证了可见性

  当一个变量被volatile修饰时，其中一个线程在其工作内存中对这个变量进行修改时，这个变量会被立即刷新回主内存，而且会使得其他线程的工作内存中这个变量的副本失效，就强制其他线程读取这个变量的时候得去主存读取，这时候读取到的值就是最新值。

  2.volatile保证了有序性

  JMM允许编译器和处理器进行指令的重排序，但是规定了as-if-serial，就是不管怎么重排序，程序的执行结果都不会改变，这是在单线程环境下可以保证的，但是在并发环境下就容易出问题。volatile就能防止指令重排序，他是通过内存屏障实现的。Java编译器会在生成指令序列时在一些位置上插入内存屏障的指令来禁止指令重排序。会在volatile变量写操作的前后加入内存屏障，会在volatile变量读操作后面加上两个内存屏障。

  * 重排序带来的问题

    双重检查单例

    new操作不为原子操作，分为三步

    >  1.分配内存空间
    >
    > 2.实例化
    >
    > 3.返回地址给引用

    若 2 3 重排序则会先返回地址给引用，这时候对象还未实例化或者说实例化不完全，这时候另一个线程判	断singleton ！= null 就直接返回了，但这个对象还是个半成品就会有问题了。

```java
    public class Singleton {

        private static volatile Singleton singleton;

        private Singleton(){}

        public static Singleton getInstance() {
            if (singleton == null) {  
                synchronized(Singleton.class) {
                    if (singleton == null) { 
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        }
    }
```

3. volatile无法保证原子性

#### synchronized

* 使用场景

  1.修饰实例方法，获取当前的this对象的锁

  2.修饰静态方法，获取当前类的Class对象的锁

  3.修饰代码块，指定一个对象，获取这个对象的锁

  如果多个同步代码块使用的是同一个对象作为锁的话，那么在一个时间点里只有一个线程能够执行到这些同步代码。

* 实现

  当编译的时候会使用monitorenter和monitorexit进行同步，当一个线程需要执行同步代码的时候需要去获取相应对象的monitor，最开始的时候，monitor的线程的进入数是0，当一个线程执行monitorenter，并且成功进入的时候就会称为这个monitor的所有者，这时候monitor的进入数就为1，如果再次进入这个monitor的时候，进入数会再加1。当退出的时候，进入数就会减1，直到monitor的进入数是0的时候，其他线程才能持有这个monitor。这是synchronized的可重入。当多个线程同时竞争monitor的时候，只有一个线程能获取monitor，其他没获取到monitor的线程会变成blocked状态然后被丢到一个同步队列中，当monitor进入数变为0的时候，同步队列里的线程就会重新去竞争monitor。

* 特性

  1.原子性：同一个时间点只有一个线程持有对象锁，保证原子性。

  2.可见性：当执行monitorenter时，会将共享变量设置为无效，使当前线程能够重新去主存读取到最新值，当执行monitorexit的时候，会将当前线程的工作内存里的共享变量刷回主存中。

  3.有序性：一种解释是synchronized使得线程排队去执行同步代码块，所以能保证有序，但是synchronized修饰的同步代码块中也是能发生指令重排序的，所以单例双重检查需要使用volatile来避免指令重排序。

* 优化

  jdk6的时候对synchronized进行过优化，加入了锁升级的过程，锁只要的四种状态分别是：无锁，偏向锁，轻量级锁和重量级锁，锁可以从偏向锁升级成轻量级锁，再从轻量级锁升级成重量级锁，但锁的升级是单向的，只能升级，不能降级。

* 锁升级过程

  在对象的对象头中存在Mark Word结构，默认无锁的状态下存储的是hashcode，分代年龄和锁标志位等一些信息，然后这个Mark Word是可复用的，也就是说在对象的不同时期，Mark Word里存储的信息也是不一样的。

  1.最开始没有被线程访问的时候为无锁状态，这时候一个线程执行同步代码的时候，synchronized就会升级为偏向锁状态，当一个线程访问同步代码块并获取偏向锁的时候，会在Mark Word里记录偏向锁偏向的线程ID，在线程进入和退出同步块时不需要通过cas来加锁和解锁，只需要检测一下Mark Word中存储的是否是当前线程的ID就行。偏向锁是为了应对一段同步代码老是只有一个线程在频繁访问的时候提高性能，减少不必要的cas开销。

  2.当锁是偏向锁的时候，这时候另一个线程尝试竞争锁，那么偏向锁就会升级为轻量级锁，其它线程竞争轻量级锁的时候会通过cas去尝试获取锁，不会阻塞，能提升性能。

  3.在轻量级锁时，如果线程自旋等待锁超过一定的次数之后，或者一个线程持有锁，另一个在等待锁，第三个到来的时候轻量级锁就会升级为重量级锁。重量级锁会使所有等待锁的线程进入阻塞状态，阻塞线程和唤醒线程的时候，操作系统需要进行系统调用，开销会增大。

  

  

  

  



